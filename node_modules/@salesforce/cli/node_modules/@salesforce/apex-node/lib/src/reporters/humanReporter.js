"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HumanReporter = void 0;
const utils_1 = require("../utils");
const i18n_1 = require("../i18n");
const os = __importStar(require("node:os"));
const UNCOVERED_LINES_ARRAY_LIMIT = 5;
class HumanReporter {
    format(testResult, detailedCoverage, concise = false) {
        utils_1.HeapMonitor.getInstance().checkHeapSize('HumanReporter.format');
        try {
            return [
                ...(!testResult.codecoverage || !detailedCoverage
                    ? [this.formatTestResults(testResult.tests, concise)]
                    : []),
                ...(testResult.codecoverage && detailedCoverage
                    ? [this.formatDetailedCov(testResult, concise)]
                    : []),
                ...(testResult.codecoverage && !concise
                    ? [this.formatCodeCov(testResult.codecoverage)]
                    : []),
                ...(testResult.setup && !concise ? [this.formatSetup(testResult)] : []),
                this.formatSummary(testResult)
            ].join(os.EOL.repeat(2));
        }
        finally {
            utils_1.HeapMonitor.getInstance().checkHeapSize('HumanReporter.format');
        }
    }
    formatSummary(testResult) {
        // Summary Table
        const summaryRowArray = [
            {
                name: i18n_1.nls.localize('outcome'),
                value: testResult.summary.outcome
            },
            {
                name: i18n_1.nls.localize('testsRan'),
                value: String(testResult.summary.testsRan)
            },
            {
                name: i18n_1.nls.localize('passRate'),
                value: testResult.summary.passRate
            },
            {
                name: i18n_1.nls.localize('failRate'),
                value: testResult.summary.failRate
            },
            {
                name: i18n_1.nls.localize('skipRate'),
                value: testResult.summary.skipRate
            },
            {
                name: i18n_1.nls.localize('testRunId'),
                value: testResult.summary.testRunId
            },
            {
                name: i18n_1.nls.localize('testSetupTime'),
                value: `${testResult.summary.testSetupTimeInMs || 0} ms`
            },
            {
                name: i18n_1.nls.localize('testExecutionTime'),
                value: `${testResult.summary.testExecutionTimeInMs} ms`
            },
            {
                name: i18n_1.nls.localize('testTotalTime'),
                value: `${testResult.summary.testTotalTimeInMs} ms`
            },
            {
                name: i18n_1.nls.localize('orgId'),
                value: testResult.summary.orgId
            },
            {
                name: i18n_1.nls.localize('username'),
                value: testResult.summary.username
            },
            ...(testResult.summary.orgWideCoverage
                ? [
                    {
                        name: i18n_1.nls.localize('orgWideCoverage'),
                        value: String(testResult.summary.orgWideCoverage)
                    }
                ]
                : [])
        ];
        return new utils_1.Table().createTable(summaryRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('nameColHeader')
            },
            { key: 'value', label: i18n_1.nls.localize('valueColHeader') }
        ], i18n_1.nls.localize('testSummaryHeader'));
    }
    formatTestResults(tests, concise) {
        const testRowArray = tests
            .filter((elem) => !concise ||
            elem.outcome === "Fail" /* ApexTestResultOutcome.Fail */ ||
            elem.outcome === "CompileFail" /* ApexTestResultOutcome.CompileFail */)
            .map((elem) => ({
            name: elem.fullName,
            outcome: elem.outcome,
            msg: buildMsg(elem),
            runtime: elem.outcome !== "Fail" /* ApexTestResultOutcome.Fail */ ? `${elem.runTime}` : ''
        }));
        if (testRowArray.length > 0) {
            return new utils_1.Table().createTable(testRowArray, [
                {
                    key: 'name',
                    label: i18n_1.nls.localize('testNameColHeader')
                },
                { key: 'outcome', label: i18n_1.nls.localize('outcomeColHeader') },
                { key: 'msg', label: i18n_1.nls.localize('msgColHeader') },
                { key: 'runtime', label: i18n_1.nls.localize('runtimeColHeader') }
            ], i18n_1.nls.localize('testResultsHeader'));
        }
        return '';
    }
    formatSetup(testResult) {
        const testRowArray = testResult.setup.map((elem) => ({
            name: elem.fullName,
            time: `${elem.testSetupTime}`,
            runId: testResult.summary.testRunId
        }));
        if (testRowArray.length > 0) {
            return new utils_1.Table().createTable(testRowArray, [
                {
                    key: 'name',
                    label: i18n_1.nls.localize('testSetupMethodNameColHeader')
                },
                { key: 'time', label: i18n_1.nls.localize('setupTimeColHeader') }
            ], i18n_1.nls
                .localize('testSetupResultsHeader')
                .replace('runId', testRowArray[0].runId));
        }
        return '';
    }
    formatDetailedCov(testResult, concise) {
        const testRowArray = testResult.tests
            .filter((elem) => !concise ||
            elem.outcome === "Fail" /* ApexTestResultOutcome.Fail */ ||
            elem.outcome === "CompileFail" /* ApexTestResultOutcome.CompileFail */)
            .flatMap((elem) => {
            const base = {
                name: elem.fullName,
                outcome: elem.outcome,
                msg: buildMsg(elem),
                runtime: `${elem.runTime}`
            };
            if (elem.perClassCoverage) {
                return elem.perClassCoverage.map((perClassCov) => ({
                    ...base,
                    coveredClassName: perClassCov.apexClassOrTriggerName,
                    coveredClassPercentage: perClassCov.percentage
                }));
            }
            return [
                {
                    ...base,
                    coveredClassName: '',
                    coveredClassPercentage: ''
                }
            ];
        });
        if (testRowArray.length > 0) {
            return new utils_1.Table().createTable(testRowArray, [
                {
                    key: 'name',
                    label: i18n_1.nls.localize('testNameColHeader')
                },
                {
                    key: 'coveredClassName',
                    label: i18n_1.nls.localize('classTestedHeader')
                },
                {
                    key: 'outcome',
                    label: i18n_1.nls.localize('outcomeColHeader')
                },
                {
                    key: 'coveredClassPercentage',
                    label: i18n_1.nls.localize('percentColHeader')
                },
                { key: 'msg', label: i18n_1.nls.localize('msgColHeader') },
                { key: 'runtime', label: i18n_1.nls.localize('runtimeColHeader') }
            ], i18n_1.nls.localize('detailedCodeCovHeader', [testResult.summary.testRunId]));
        }
        return '';
    }
    formatCodeCov(codeCoverages) {
        const codeCovRowArray = codeCoverages.map((elem) => ({
            name: elem.name,
            percent: elem.percentage,
            uncoveredLines: formatUncoveredLines(elem.uncoveredLines)
        }));
        return new utils_1.Table().createTable(codeCovRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('classesColHeader')
            },
            {
                key: 'percent',
                label: i18n_1.nls.localize('percentColHeader')
            },
            {
                key: 'uncoveredLines',
                label: i18n_1.nls.localize('uncoveredLinesColHeader')
            }
        ], i18n_1.nls.localize('codeCovHeader'));
    }
}
exports.HumanReporter = HumanReporter;
__decorate([
    (0, utils_1.elapsedTime)()
], HumanReporter.prototype, "format", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanReporter.prototype, "formatSummary", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanReporter.prototype, "formatTestResults", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanReporter.prototype, "formatSetup", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanReporter.prototype, "formatDetailedCov", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanReporter.prototype, "formatCodeCov", null);
const buildMsg = (elem) => elem.stackTrace
    ? `${elem.message}\n${elem.stackTrace}`
    : (elem.message ?? '');
const formatUncoveredLines = (uncoveredLines) => uncoveredLines.length === 0
    ? ''
    : uncoveredLines
        .slice(0, Math.min(uncoveredLines.length, UNCOVERED_LINES_ARRAY_LIMIT))
        .map((line) => line.toString())
        .concat(uncoveredLines.length > UNCOVERED_LINES_ARRAY_LIMIT ? ['...'] : [])
        .join(',');
//# sourceMappingURL=humanReporter.js.map