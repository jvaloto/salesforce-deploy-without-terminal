import type { Profile } from '@salesforce/types/metadata';
import { PackageXml } from '../interfaces';
export type CorrectedProfile = Profile;
/**
 *
 * Takes a Profile that's been converted from package.xml to json.
 * Filters out all Profile props that are not
 * 1. used by packaging (ex: ipRanges)
 * 2. present in the package.xml (ex: ClassAccesses for a class not in the package)
 * 3. optionally retains the UserLicense prop only if the param is true
 *
 * @param profileJson json representation of a profile
 * @param packageXml package.xml as json
 * @param retainUserLicense boolean will preserve userLicense if true
 * @returns Profile
 */
export declare const profileRewriter: (profileJson: CorrectedProfile, packageXml: PackageMap, retainUserLicense?: boolean) => CorrectedProfile;
export declare const fieldCorrections: (fieldName: string) => string;
/**
 * @param profileString: raw xml read from the file
 * @returns CorrectedProfile (json representation of the profile)
 */
export declare const profileStringToProfile: (profileString: string) => CorrectedProfile;
/** pass in an object that has the Profile props at the top level.
 * This function will add the outer wrapper `Profile`  and convert the result to xml
 * */
export declare const profileObjectToString: (profileObject: Partial<CorrectedProfile>) => string;
/** it's easier to do lookups by Metadata Type on a Map */
export declare const manifestTypesToMap: (original: PackageXml["types"]) => PackageMap;
type PackageMap = Map<string, string[]>;
export {};
