/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Global, SfError, TTLConfig } from '@salesforce/core';
import { Duration } from '@salesforce/kit';
export class AgentTestCache extends TTLConfig {
    static getFileName() {
        return 'agent-test-cache.json';
    }
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: AgentTestCache.getFileName(),
            stateFolder: Global.SF_STATE_FOLDER,
            ttl: Duration.days(7),
        };
    }
    async createCacheEntry(runId, name, outputDir, resultFormat) {
        if (!runId)
            throw new SfError('runId is required to create a cache entry');
        this.set(runId, { runId, name, outputDir, resultFormat });
        await this.write();
    }
    async removeCacheEntry(runId) {
        if (!runId)
            throw new SfError('runId is required to remove a cache entry');
        this.unset(runId);
        await this.write();
    }
    resolveFromCache() {
        const key = this.getLatestKey();
        if (!key)
            throw new SfError('Could not find a runId to resume');
        return this.get(key);
    }
    useIdOrMostRecent(runId, useMostRecent) {
        if (runId && useMostRecent) {
            throw new SfError('Cannot specify both a runId and use most recent flag');
        }
        if (!runId && !useMostRecent) {
            throw new SfError('Must specify either a runId or use most recent flag');
        }
        if (runId) {
            return this.has(runId) ? this.get(runId) : { runId };
        }
        return this.resolveFromCache();
    }
}
//# sourceMappingURL=agentTestCache.js.map