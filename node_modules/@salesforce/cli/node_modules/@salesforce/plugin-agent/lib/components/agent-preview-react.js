/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import path from 'node:path';
import fs from 'node:fs';
import React from 'react';
import { Box, Text, useInput } from 'ink';
import TextInput from 'ink-text-input';
import { writeDebugLog } from '@salesforce/agents';
import { sleep } from '@salesforce/kit';
// Component to show a simple typing animation
function Typing() {
    const [frame, setFrame] = React.useState(0);
    React.useEffect(() => {
        const timer = setInterval(() => {
            setFrame((prev) => (prev + 1) % 4);
        }, 350);
        return () => clearInterval(timer);
    }, []);
    const colors = ['grey', 'grey', 'grey'];
    colors[frame] = 'white';
    return (React.createElement(Text, null,
        React.createElement(Text, { color: colors[0] }, "."),
        React.createElement(Text, { color: colors[1] }, "."),
        React.createElement(Text, { color: colors[2] }, ".")));
}
// Split the content on newlines, then find the longest array element
const calculateWidth = (content) => content.split('\n').reduce((acc, line) => Math.max(acc, line.length), 0) + 4;
const saveTranscriptsToFile = (outputDir, messages, responses) => {
    if (!outputDir)
        return;
    fs.mkdirSync(outputDir, { recursive: true });
    const transcriptPath = path.join(outputDir, 'transcript.json');
    fs.writeFileSync(transcriptPath, JSON.stringify(messages, null, 2));
    const responsesPath = path.join(outputDir, 'responses.json');
    fs.writeFileSync(responsesPath, JSON.stringify(responses, null, 2));
};
/**
 * Ideas:
 * - Limit height based on terminal height
 * - Add keystroke to clear chat
 * - Add keystroke to scroll up
 * - Add keystroke to scroll down
 */
export function AgentPreviewReact(props) {
    const [messages, setMessages] = React.useState([]);
    const [header, setHeader] = React.useState('Starting session...');
    const [sessionId, setSessionId] = React.useState('');
    const [query, setQuery] = React.useState('');
    const [isTyping, setIsTyping] = React.useState(true);
    const [sessionEnded, setSessionEnded] = React.useState(false);
    // @ts-expect-error: Complains if this is not defined but it's not used
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const [timestamp, setTimestamp] = React.useState(new Date().getTime());
    const [tempDir, setTempDir] = React.useState('');
    const [responses, setResponses] = React.useState([]);
    const [apexDebugLogs, setApexDebugLogs] = React.useState([]);
    const { connection, agent, name, outputDir } = props;
    useInput((input, key) => {
        if (key.escape) {
            setSessionEnded(true);
        }
        if (key.ctrl && input === 'c') {
            setSessionEnded(true);
        }
    });
    React.useEffect(() => {
        const endSession = async () => {
            if (sessionEnded) {
                // TODO: Support other end types (such as Escalate)
                await agent.end(sessionId, 'UserRequest');
                process.exit(0);
            }
        };
        void endSession();
    }, [sessionEnded]);
    React.useEffect(() => {
        const startSession = async () => {
            const session = await agent.start();
            setSessionId(session.sessionId);
            setHeader(`New session started with "${props.name}" (${session.sessionId})`);
            await sleep(500); // Add a short delay to make it feel more natural
            setIsTyping(false);
            if (outputDir) {
                const dateForDir = new Date().toISOString().replace(/:/g, '-').split('.')[0];
                setTempDir(path.join(outputDir, `${dateForDir}--${session.sessionId}`));
            }
            setMessages([{ role: name, content: session.messages[0].message, timestamp: new Date() }]);
        };
        void startSession();
    }, []);
    React.useEffect(() => {
        saveTranscriptsToFile(tempDir, messages, responses);
    }, [tempDir, messages, responses]);
    return (React.createElement(Box, { flexDirection: "column" },
        React.createElement(Box, { flexDirection: "column", width: process.stdout.columns, borderStyle: "round", alignItems: "center", marginTop: 1, marginBottom: 1, paddingLeft: 1, paddingRight: 1 },
            React.createElement(Text, { bold: true }, header)),
        messages.length > 0 && (React.createElement(Box, { flexDirection: "column" }, messages.map(({ timestamp: ts, role, content }, idx) => (React.createElement(Box, { key: role + '__' + ts.toISOString() + '__' + idx.toString(), alignItems: role === 'user' ? 'flex-end' : 'flex-start', flexDirection: "column" },
            React.createElement(Box, { flexDirection: "row", columnGap: 1 },
                React.createElement(Text, null, role === 'user' ? 'You' : role),
                React.createElement(Text, { color: "grey" }, ts.toLocaleString())),
            React.createElement(Box
            // Use 70% of the terminal width, or the width of a single line of content, whichever is smaller
            , { 
                // Use 70% of the terminal width, or the width of a single line of content, whichever is smaller
                width: Math.min(process.stdout.columns * 0.7, calculateWidth(content)), borderStyle: "round", paddingLeft: 1, paddingRight: 1 },
                React.createElement(Text, null, content))))))),
        isTyping ? (React.createElement(Box, { flexDirection: "column" },
            React.createElement(Box, { alignItems: "flex-start", flexDirection: "column" },
                React.createElement(Box, { flexDirection: "row", columnGap: 1 },
                    React.createElement(Text, null, name),
                    React.createElement(Text, { color: "grey" }, new Date().toLocaleString())),
                React.createElement(Box, { width: 7, borderStyle: "round", paddingLeft: 1, paddingRight: 1 },
                    React.createElement(Typing, null))))) : null,
        React.createElement(Box, { paddingLeft: 1, paddingRight: 1 },
            React.createElement(Text, { dimColor: true }, 'â”€'.repeat(process.stdout.columns - 2))),
        React.createElement(Box, { marginBottom: 1 },
            React.createElement(Text, null, "> "),
            React.createElement(TextInput, { showCursor: true, value: query, placeholder: "Start typing (press ESC to exit)", onChange: setQuery, 
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                onSubmit: async (content) => {
                    if (!content)
                        return;
                    setQuery('');
                    // Add the most recent user message to the chat window
                    setMessages((prev) => [...prev, { role: 'user', content, timestamp: new Date() }]);
                    setIsTyping(true);
                    const response = await agent.send(sessionId, content);
                    setResponses((prev) => [...prev, response]);
                    const message = response.messages[0].message;
                    if (!message) {
                        throw new Error('Failed to send message');
                    }
                    setIsTyping(false);
                    // Add the agent's response to the chat
                    setMessages((prev) => [...prev, { role: name, content: message, timestamp: new Date() }]);
                    // If there is an apex debug log entry, get the log and write it to the output dir
                    if (response.apexDebugLog && tempDir) {
                        // Write the apex debug to the output dir
                        await writeDebugLog(connection, response.apexDebugLog, tempDir);
                        const logId = response.apexDebugLog.Id;
                        if (logId) {
                            setApexDebugLogs((prev) => [...prev, path.join(tempDir, `${logId}.log`)]);
                        }
                    }
                } })),
        sessionEnded ? (React.createElement(Box, { flexDirection: "column", width: process.stdout.columns, borderStyle: "round", marginTop: 1, marginBottom: 1, paddingLeft: 1, paddingRight: 1 },
            React.createElement(Text, { bold: true }, "Session Ended"),
            outputDir ? React.createElement(Text, null,
                "Conversation log: ",
                tempDir,
                "/transcript.json") : null,
            outputDir ? React.createElement(Text, null,
                "API transactions: ",
                tempDir,
                "/responses.json") : null,
            apexDebugLogs.length > 0 && React.createElement(Text, null,
                "Apex Debug Logs: ",
                '\n' + apexDebugLogs.join('\n')))) : null));
}
//# sourceMappingURL=agent-preview-react.js.map