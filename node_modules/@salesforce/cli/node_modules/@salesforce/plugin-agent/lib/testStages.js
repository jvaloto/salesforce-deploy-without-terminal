/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { colorize } from '@oclif/core/ux';
import { MultiStageOutput } from '@oclif/multi-stage-output';
import { Lifecycle } from '@salesforce/core';
import { Ux } from '@salesforce/sf-plugins-core';
const isTimeoutError = (e) => e?.name === 'PollingClientTimeout';
export class TestStages {
    mso;
    ux;
    constructor({ title, jsonEnabled }) {
        this.ux = new Ux({ jsonEnabled });
        this.mso = new MultiStageOutput({
            title,
            jsonEnabled,
            stages: ['Starting Tests', 'Polling for Test Results'],
            stageSpecificBlock: [
                {
                    stage: 'Polling for Test Results',
                    type: 'dynamic-key-value',
                    label: 'Status',
                    get: (data) => data?.status,
                },
                {
                    stage: 'Polling for Test Results',
                    type: 'dynamic-key-value',
                    label: 'Completed Test Cases',
                    get: (data) => data?.totalTestCases && data?.passingTestCases >= 0 && data?.failingTestCases >= 0
                        ? `${data?.passingTestCases + data?.failingTestCases}/${data?.totalTestCases}`
                        : undefined,
                },
                {
                    stage: 'Polling for Test Results',
                    type: 'dynamic-key-value',
                    label: 'Passing Test Cases',
                    get: (data) => data?.passingTestCases?.toString(),
                },
                {
                    stage: 'Polling for Test Results',
                    type: 'dynamic-key-value',
                    label: 'Failing Test Cases',
                    get: (data) => data?.failingTestCases?.toString(),
                },
            ],
            postStagesBlock: [
                {
                    type: 'dynamic-key-value',
                    label: 'Job ID',
                    get: (data) => data?.id,
                },
            ],
        });
    }
    start(data) {
        this.mso.skipTo('Starting Tests', data);
    }
    async poll(agentTester, id, wait) {
        this.mso.skipTo('Polling for Test Results');
        const lifecycle = Lifecycle.getInstance();
        lifecycle.on('AGENT_TEST_POLLING_EVENT', async (event) => Promise.resolve(this.update(event)));
        try {
            const response = await agentTester.poll(id, { timeout: wait });
            this.stop();
            return { completed: true, response };
        }
        catch (e) {
            if (isTimeoutError(e)) {
                this.stop('async');
                this.ux.log(`Client timed out after ${wait.minutes} minutes.`);
                this.ux.log(`Run ${colorize('dim', `sf agent test resume --job-id ${id}`)} to resuming watching this test.`);
                return { completed: true };
            }
            else {
                this.error();
                throw e;
            }
        }
    }
    update(data) {
        this.mso.updateData(data);
    }
    stop(finalStatus) {
        this.mso.stop(finalStatus);
    }
    error() {
        this.mso.error();
    }
    done(data) {
        this.mso.skipTo('Done', data);
    }
}
//# sourceMappingURL=testStages.js.map