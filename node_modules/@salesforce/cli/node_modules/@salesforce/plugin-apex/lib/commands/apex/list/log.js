/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { LogService } from '@salesforce/apex-node';
import { SfCommand, requiredOrgFlagWithDeprecations, orgApiVersionFlagWithDeprecations, loglevel, } from '@salesforce/sf-plugins-core';
import { Messages } from '@salesforce/core';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-apex', 'list');
export default class Log extends SfCommand {
    static summary = messages.getMessage('summary');
    static description = messages.getMessage('description');
    static examples = messages.getMessages('examples');
    static deprecateAliases = true;
    static aliases = ['force:apex:log:list'];
    static flags = {
        'target-org': requiredOrgFlagWithDeprecations,
        'api-version': orgApiVersionFlagWithDeprecations,
        loglevel,
    };
    async run() {
        const { flags } = await this.parse(Log);
        const logService = new LogService(flags['target-org'].getConnection(flags['api-version']));
        const logRecords = (await logService.getLogRecords()).map(formatStartTime);
        if (logRecords.length === 0) {
            this.log(messages.getMessage('noDebugLogsFound'));
            return [];
        }
        if (!flags.json) {
            // while not required to prevent table output, save a few iterations if only printing json
            this.table({
                data: logRecords.map(formatForTable),
                columns: [
                    'Application',
                    { key: 'DurationMilliseconds', name: 'Duration (ms)' },
                    'Id',
                    'Location',
                    { key: 'LogLength', name: 'Size (B)' },
                    { key: 'User', name: 'Log User' },
                    'Operation',
                    'Request',
                    { key: 'StartTime', name: 'Start Time' },
                    'Status',
                ],
                overflow: 'wrap',
            });
        }
        return logRecords;
    }
}
const formatForTable = (logRecord) => ({
    ...logRecord,
    DurationMilliseconds: String(logRecord.DurationMilliseconds),
    User: logRecord.LogUser.Name,
});
export const formatStartTime = (lr) => ({ ...lr, StartTime: formatTime(lr.StartTime) });
const formatTime = (time) => {
    const msIndex = time.indexOf('.');
    return msIndex !== -1 ? time.substring(0, msIndex) + time.substring(msIndex + 4) : time;
};
//# sourceMappingURL=log.js.map