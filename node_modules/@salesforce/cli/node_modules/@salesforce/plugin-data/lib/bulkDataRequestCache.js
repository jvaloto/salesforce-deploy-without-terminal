/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { TTLConfig, Global, Logger, Messages, Org } from '@salesforce/core';
import { Duration } from '@salesforce/kit';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-data', 'messages');
export class BulkDataRequestCache extends TTLConfig {
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: BulkDataRequestCache.getFileName(),
            stateFolder: Global.SF_STATE_FOLDER,
            ttl: Duration.days(3),
        };
    }
    /**
     * Creates a new bulk data request cache entry for the given bulk request id.
     *
     * @param bulkRequestId
     * @param username
     */
    async createCacheEntryForRequest(bulkRequestId, username, apiVersion) {
        if (!username) {
            throw messages.createError('usernameRequired');
        }
        this.set(bulkRequestId, {
            jobId: bulkRequestId,
            username,
            apiVersion,
        });
        await this.write();
        Logger.childFromRoot('DataRequestCache').debug(`bulk cache saved for ${bulkRequestId}`);
    }
    /**
     * Resolve entries from the local cache.
     *
     * @param jobIdOrMostRecent job ID or boolean value to decide if it should return the most recent entry in the cache.
     * @param skipCacheValidatation make this method not throw if you passed a job ID that's not in the cache
     * This was only added for `data upsert/delete resume` for backwards compatibility and will be removed after March 2025.
     */
    async resolveResumeOptionsFromCache(jobIdOrMostRecent) {
        if (typeof jobIdOrMostRecent === 'boolean') {
            const key = this.getLatestKey();
            if (!key) {
                throw messages.createError('error.missingCacheEntryError');
            }
            // key definitely exists because it came from the cache
            const entry = this.get(key);
            return {
                jobInfo: { id: entry.jobId },
                options: {
                    connection: (await Org.create({ aliasOrUsername: entry.username })).getConnection(),
                },
            };
        }
        else {
            const entry = this.get(jobIdOrMostRecent);
            if (!entry) {
                throw messages.createError('error.bulkRequestIdNotFound', [jobIdOrMostRecent]);
            }
            return {
                jobInfo: { id: entry.jobId },
                options: {
                    connection: (await Org.create({ aliasOrUsername: entry.username })).getConnection(),
                },
            };
        }
    }
}
export class BulkDeleteRequestCache extends BulkDataRequestCache {
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: BulkDeleteRequestCache.getFileName(),
            stateFolder: Global.SF_STATE_FOLDER,
            ttl: Duration.days(3),
        };
    }
    static getFileName() {
        return 'bulk-data-delete-cache.json';
    }
    static async unset(key) {
        const cache = await BulkDeleteRequestCache.create();
        cache.unset(key);
        await cache.write();
    }
}
export class BulkUpsertRequestCache extends BulkDataRequestCache {
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: BulkUpsertRequestCache.getFileName(),
            stateFolder: Global.SF_STATE_FOLDER,
            ttl: Duration.days(3),
        };
    }
    static getFileName() {
        return 'bulk-data-upsert-cache.json';
    }
    static async unset(key) {
        const cache = await BulkUpsertRequestCache.create();
        cache.unset(key);
        await cache.write();
    }
}
export class BulkImportRequestCache extends TTLConfig {
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: BulkImportRequestCache.getFileName(),
            stateFolder: Global.SF_STATE_FOLDER,
            ttl: Duration.days(7),
        };
    }
    static getFileName() {
        return 'bulk-data-import-cache.json';
    }
    static async unset(key) {
        const cache = await BulkImportRequestCache.create();
        cache.unset(key);
        await cache.write();
    }
    /**
     * Creates a new bulk data import cache entry for the given bulk request id.
     *
     * @param bulkRequestId
     * @param username
     * @param apiVersion
     */
    async createCacheEntryForRequest(bulkRequestId, username, apiVersion) {
        this.set(bulkRequestId, {
            jobId: bulkRequestId,
            username,
            apiVersion,
        });
        await this.write();
        Logger.childFromRoot('BulkImportCache').debug(`bulk cache saved for ${bulkRequestId}`);
    }
    async resolveResumeOptionsFromCache(jobIdOrMostRecent) {
        if (typeof jobIdOrMostRecent === 'boolean') {
            const key = this.getLatestKey();
            if (!key) {
                throw messages.createError('error.missingCacheEntryError');
            }
            // key definitely exists because it came from the cache
            const entry = this.get(key);
            return {
                jobInfo: { id: entry.jobId },
                options: {
                    connection: (await Org.create({ aliasOrUsername: entry.username })).getConnection(),
                },
            };
        }
        else {
            const entry = this.get(jobIdOrMostRecent);
            if (!entry) {
                throw messages.createError('error.bulkRequestIdNotFound', [jobIdOrMostRecent]);
            }
            return {
                jobInfo: { id: entry.jobId },
                options: {
                    connection: (await Org.create({ aliasOrUsername: entry.username })).getConnection(),
                },
            };
        }
    }
}
export class BulkUpdateRequestCache extends TTLConfig {
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: BulkUpdateRequestCache.getFileName(),
            stateFolder: Global.SF_STATE_FOLDER,
            ttl: Duration.days(7),
        };
    }
    static getFileName() {
        return 'bulk-data-update-cache.json';
    }
    static async unset(key) {
        const cache = await BulkImportRequestCache.create();
        cache.unset(key);
        await cache.write();
    }
    /**
     * Creates a new bulk data import cache entry for the given bulk request id.
     *
     * @param bulkRequestId
     * @param username
     * @param apiVersion
     */
    async createCacheEntryForRequest(bulkRequestId, username, apiVersion) {
        this.set(bulkRequestId, {
            jobId: bulkRequestId,
            username,
            apiVersion,
        });
        await this.write();
        Logger.childFromRoot('BulkUpdateCache').debug(`bulk cache saved for ${bulkRequestId}`);
    }
    async resolveResumeOptionsFromCache(jobIdOrMostRecent) {
        if (typeof jobIdOrMostRecent === 'boolean') {
            const key = this.getLatestKey();
            if (!key) {
                throw messages.createError('error.missingCacheEntryError');
            }
            // key definitely exists because it came from the cache
            const entry = this.get(key);
            return {
                jobInfo: { id: entry.jobId },
                options: {
                    connection: (await Org.create({ aliasOrUsername: entry.username })).getConnection(),
                },
            };
        }
        else {
            const entry = this.get(jobIdOrMostRecent);
            if (!entry) {
                throw messages.createError('error.bulkRequestIdNotFound', [jobIdOrMostRecent]);
            }
            return {
                jobInfo: { id: entry.jobId },
                options: {
                    connection: (await Org.create({ aliasOrUsername: entry.username })).getConnection(),
                },
            };
        }
    }
}
export class BulkExportRequestCache extends TTLConfig {
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: BulkExportRequestCache.getFileName(),
            stateFolder: Global.SF_STATE_FOLDER,
            ttl: Duration.days(7),
        };
    }
    static getFileName() {
        return 'bulk-data-export-cache.json';
    }
    static async unset(key) {
        const cache = await BulkUpsertRequestCache.create();
        cache.unset(key);
        await cache.write();
    }
    /**
     * Creates a new bulk export request cache entry for the given id.
     */
    async createCacheEntryForRequest(bulkRequestId, outputInfo, username, apiVersion) {
        if (!username) {
            throw messages.createError('usernameRequired');
        }
        this.set(bulkRequestId, {
            jobId: bulkRequestId,
            outputInfo,
            username,
            apiVersion,
        });
        await this.write();
        Logger.childFromRoot('BulkExportCache').debug(`bulk cache saved for ${bulkRequestId}`);
    }
    async resolveResumeOptionsFromCache(jobIdOrMostRecent, apiVersion) {
        if (typeof jobIdOrMostRecent === 'boolean') {
            const key = this.getLatestKey();
            if (!key) {
                throw messages.createError('error.missingCacheEntryError');
            }
            // key definitely exists because it came from the cache
            const entry = this.get(key);
            return {
                jobInfo: { id: entry.jobId },
                outputInfo: {
                    filePath: entry.outputInfo.filePath,
                    format: entry.outputInfo.format,
                    columnDelimiter: entry.outputInfo.columnDelimiter,
                },
                options: {
                    connection: (await Org.create({ aliasOrUsername: entry.username })).getConnection(apiVersion),
                },
            };
        }
        else {
            const entry = this.get(jobIdOrMostRecent);
            if (!entry) {
                throw messages.createError('error.bulkRequestIdNotFound', [jobIdOrMostRecent]);
            }
            return {
                jobInfo: { id: entry.jobId },
                outputInfo: entry.outputInfo,
                options: {
                    connection: (await Org.create({ aliasOrUsername: entry.username })).getConnection(apiVersion),
                },
            };
        }
    }
}
//# sourceMappingURL=bulkDataRequestCache.js.map