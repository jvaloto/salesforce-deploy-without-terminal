/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import fs from 'node:fs';
import { Logger, Messages } from '@salesforce/core';
import { ensureJsonArray, ensureJsonMap, ensureString, getArray, isJsonArray, toJsonMap, } from '@salesforce/ts-types';
import { SfCommand, Flags } from '@salesforce/sf-plugins-core';
import { orgFlags, perflogFlag, resultFormatFlag } from '../../flags.js';
import { FieldType } from '../../types.js';
import { displayResults } from '../../queryUtils.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-data', 'soql.query');
export class DataSoqlQueryCommand extends SfCommand {
    static summary = messages.getMessage('summary');
    static description = messages.getMessage('description');
    static examples = messages.getMessages('examples');
    static aliases = ['force:data:soql:query'];
    static deprecateAliases = true;
    static flags = {
        ...orgFlags,
        query: Flags.string({
            char: 'q',
            summary: messages.getMessage('flags.query.summary'),
            exactlyOne: ['query', 'file'],
        }),
        file: Flags.file({
            char: 'f',
            exists: true,
            summary: messages.getMessage('flags.file.summary'),
            exactlyOne: ['query', 'file'],
            aliases: ['soqlqueryfile'],
            deprecateAliases: true,
        }),
        'use-tooling-api': Flags.boolean({
            char: 't',
            summary: messages.getMessage('flags.use-tooling-api.summary'),
            aliases: ['usetoolingapi'],
            deprecateAliases: true,
        }),
        'all-rows': Flags.boolean({
            summary: messages.getMessage('flags.all-rows.summary'),
        }),
        'result-format': resultFormatFlag(),
        perflog: perflogFlag,
        'output-file': Flags.file({
            summary: messages.getMessage('flags.output-file.summary'),
            relationships: [
                {
                    type: 'some',
                    flags: [
                        {
                            name: 'result-format',
                            // eslint-disable-next-line @typescript-eslint/require-await
                            when: async (flags) => flags['result-format'] === 'csv' || flags['result-format'] === 'json',
                        },
                    ],
                },
            ],
        }),
    };
    logger;
    // will init from run
    /**
     * Command run implementation
     *
     * Returns either a DataSoqlQueryResult or a SfdxResult.
     * When the user is using global '--json' flag an instance of SfdxResult is returned.
     * This is necessary since '--json' flag reports results in the form of SfdxResult
     * and bypasses the definition of start result. The goal is to have the output
     * from '--json' and '--result-format json' be the same.
     *
     * The DataSoqlQueryResult is necessary to communicate user selections to the reporters.
     * The 'this' object available during display() function does not include user input to
     * the command, which are necessary for reporter selection.
     *
     */
    async run() {
        this.logger = await Logger.child('data:soql:query');
        const flags = (await this.parse(DataSoqlQueryCommand)).flags;
        try {
            // --file will be present if flags.query isn't. Oclif exactlyOne isn't quite that clever
            const queryString = flags.query ?? fs.readFileSync(flags.file, 'utf8');
            const conn = flags['target-org'].getConnection(flags['api-version']);
            if (flags['result-format'] !== 'json')
                this.spinner.start(messages.getMessage('queryRunningMessage'));
            const queryResult = await this.runSoqlQuery(flags['use-tooling-api'] ? conn.tooling : conn, queryString, this.logger, this.configAggregator.getInfo('org-max-query-limit').value, flags['all-rows']);
            if (flags['output-file'] ?? !this.jsonEnabled()) {
                displayResults({ ...queryResult }, flags['result-format'], flags['output-file']);
            }
            if (flags['output-file']) {
                this.log(`${queryResult.result.totalSize} records written to ${flags['output-file']}`);
                return { ...queryResult.result, outputFile: flags['output-file'] };
            }
            else {
                return queryResult.result;
            }
        }
        finally {
            if (flags['result-format'] !== 'json')
                this.spinner.stop();
        }
    }
    async runSoqlQuery(connection, query, logger, maxFetch = 50_000, allRows = false) {
        logger.debug('running query');
        const result = await connection.query(query, {
            autoFetch: true,
            maxFetch,
            scanAll: allRows,
        });
        if (result.records.length && result.totalSize > result.records.length) {
            this.warn(`The query result is missing ${result.totalSize - result.records.length} records due to a ${maxFetch} record limit. Increase the number of records returned by setting the config value "org-max-query-limit" or the environment variable "SF_ORG_MAX_QUERY_LIMIT" to ${result.totalSize} or greater than ${maxFetch}.`);
        }
        logger.debug(`Query complete with ${result.totalSize} records returned`);
        const columns = result.totalSize ? await retrieveColumns(connection, query, logger) : [];
        return {
            query,
            columns,
            result,
        };
    }
}
const searchSubColumnsRecursively = (parent) => {
    const column = ensureJsonMap(parent);
    const name = ensureString(column.columnName);
    const child = getArray(parent, 'joinColumns');
    return child.length ? child.map((c) => `${name}.${searchSubColumnsRecursively(c).join('.')}`) : [name];
};
/**
 * Utility to fetch the columns involved in a soql query.
 *
 * Columns are then transformed into one of three types, Field, SubqueryField and FunctionField. List of
 * fields is returned as the product.
 *
 * @param connection
 * @param query
 * @param logger
 */
export const retrieveColumns = async (connection, query, logger) => {
    logger?.debug('fetching columns for query');
    // eslint-disable-next-line no-underscore-dangle
    const columnUrl = `${connection._baseUrl()}/query?q=${encodeURIComponent(query)}&columns=true`;
    const results = toJsonMap(await connection.request(columnUrl));
    return recursivelyFindColumns(ensureJsonArray(results.columnMetadata));
};
const recursivelyFindColumns = (data) => {
    const columns = [];
    for (let column of data) {
        column = ensureJsonMap(column);
        const name = ensureString(column.columnName);
        if (isJsonArray(column.joinColumns) && column.joinColumns.length > 0) {
            if (column.aggregate) {
                const field = {
                    fieldType: FieldType.subqueryField,
                    name,
                    fields: [],
                };
                for (let subcolumn of column.joinColumns) {
                    subcolumn = ensureJsonMap(subcolumn);
                    if (isJsonArray(column.joinColumns) && column.joinColumns.length > 0) {
                        if (field.fields)
                            field.fields.push(...recursivelyFindColumns([subcolumn]));
                    }
                    else {
                        const f = {
                            fieldType: FieldType.field,
                            name: ensureString(ensureJsonMap(subcolumn).columnName),
                        };
                        if (field.fields)
                            field.fields.push(f);
                    }
                }
                columns.push(field);
            }
            else {
                for (const subcolumn of column.joinColumns) {
                    const allSubFieldNames = searchSubColumnsRecursively(subcolumn);
                    for (const subFields of allSubFieldNames) {
                        columns.push({
                            fieldType: FieldType.field,
                            name: `${name}.${subFields}`,
                        });
                    }
                }
            }
        }
        else if (column.aggregate) {
            const field = {
                fieldType: FieldType.functionField,
                name: ensureString(column.displayName),
            };
            // If it isn't an alias, skip so the display name is used when messaging rows
            if (!/expr[0-9]+/.test(name)) {
                field.alias = name;
            }
            columns.push(field);
        }
        else {
            columns.push({ fieldType: FieldType.field, name });
        }
    }
    return columns;
};
//# sourceMappingURL=query.js.map