/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import got from 'got';
import { ProxyAgent } from 'proxy-agent';
import { sleep } from '@salesforce/kit';
const agent = { https: new ProxyAgent() };
const retryWithBackoff = async (fn, maxRetries = 3, initialDelay = 1000) => {
    try {
        return await fn();
    }
    catch (error) {
        if (error instanceof Error &&
            'response' in error &&
            typeof error.response === 'object' &&
            error.response !== null &&
            'statusCode' in error.response &&
            error.response.statusCode === 429 &&
            maxRetries > 0) {
            await sleep(initialDelay);
            return retryWithBackoff(fn, maxRetries - 1, initialDelay * 2);
        }
        throw error;
    }
};
export const query = async (packages) => {
    const results = [];
    for (const pkg of packages) {
        // eslint-disable-next-line no-await-in-loop
        const result = await Promise.all([
            retryWithBackoff(() => got(`https://registry.npmjs.org/${pkg}/latest`, { agent }).json()),
            retryWithBackoff(() => got(`https://api.npmjs.org/downloads/point/last-week/${pkg}`, { agent }).json()),
            retryWithBackoff(() => got(`https://registry.yarnpkg.com/-/v1/search?text=${pkg}`, { agent }).json()),
        ]);
        results.push(result);
        // Add a small delay between packages to avoid rate limiting
        // eslint-disable-next-line no-await-in-loop
        await sleep(100);
    }
    return results;
};
export const transform = (queryResult) => queryResult
    .map((y) => ({ ...y[0], ...y[1], published: dateFromSearchObjects(y[0].name, y[2]) }))
    .sort((a, b) => (b.downloads > a.downloads ? 1 : -1))
    .map((y) => ({
    ...y,
    homepage: y.homepage.replace('https://github.com/https://github.com', 'https://github.com'),
}));
const dateFromSearchObjects = (pkgName, searchInfo) => searchInfo.objects.find((o) => o.package.name === pkgName)?.package.date.split('T')[0] ?? '';
/** word wrap inside the description.  Also removes line empty lines and markdown dividers */
export const descriptionTransform = (description) => (description
    // links and image links
    .replace(/\[.*\]\(.*\)/g, '')
    // line dividers
    .replace(/={2,}/g, '')
    .trim()
    // separate into shorter lines
    .match(/(.{1,50})(?:\s|$)/g)
    ?.map((line) => line.trim())
    .join('\n') ?? '')
    // remove empty lines
    .replace(/\n{2,}/gm, '\n');
export default {
    query,
    transform,
    descriptionTransform,
};
//# sourceMappingURL=discoverQuery.js.map