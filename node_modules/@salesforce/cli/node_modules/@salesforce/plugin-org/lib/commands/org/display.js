/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Flags, SfCommand, requiredOrgFlagWithDeprecations, loglevel, orgApiVersionFlagWithDeprecations, } from '@salesforce/sf-plugins-core';
import { AuthInfo, Messages, SfError, trimTo15 } from '@salesforce/core';
import { camelCaseToTitleCase } from '@salesforce/kit';
import { getAliasByUsername } from '../../shared/utils.js';
import { getStyledValue } from '../../shared/orgHighlighter.js';
import { OrgListUtil } from '../../shared/orgListUtil.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-org', 'display');
const sharedMessages = Messages.loadMessages('@salesforce/plugin-org', 'messages');
export class OrgDisplayCommand extends SfCommand {
    static summary = messages.getMessage('summary');
    static description = messages.getMessage('description');
    static examples = messages.getMessages('examples');
    static aliases = ['force:org:display'];
    static deprecateAliases = true;
    static flags = {
        'target-org': requiredOrgFlagWithDeprecations,
        'api-version': orgApiVersionFlagWithDeprecations,
        verbose: Flags.boolean({
            summary: messages.getMessage('flags.verbose.summary'),
        }),
        loglevel,
    };
    org;
    async run() {
        const { flags } = await this.parse(OrgDisplayCommand);
        this.org = flags['target-org'];
        this.org.getConnection(flags['api-version']);
        try {
            // the auth file might have a stale access token.  We want to refresh it before getting the fields
            await this.org.refreshAuth();
        }
        catch (error) {
            // even if this fails, we want to display the information we can read from the auth file
            this.warn('unable to refresh auth for org');
        }
        // translate to alias if necessary
        const authInfo = await AuthInfo.create({ username: this.org.getUsername() });
        const fields = authInfo.getFields(true);
        const isScratchOrg = Boolean(fields.devHubUsername);
        const scratchOrgInfo = isScratchOrg && fields.orgId ? await this.getScratchOrgInformation(fields) : {};
        const returnValue = {
            // renamed properties
            id: fields.orgId,
            devHubId: fields.devHubUsername,
            // copied properties
            apiVersion: fields.instanceApiVersion,
            accessToken: fields.accessToken,
            instanceUrl: fields.instanceUrl,
            username: fields.username,
            clientId: fields.clientId,
            password: fields.password,
            ...scratchOrgInfo,
            // properties with more complex logic
            connectedStatus: isScratchOrg
                ? undefined
                : await OrgListUtil.determineConnectedStatusForNonScratchOrg(fields.username),
            sfdxAuthUrl: flags.verbose && fields.refreshToken ? authInfo.getSfdxAuthUrl() : undefined,
            alias: await getAliasByUsername(fields.username),
            clientApps: fields.clientApps ? Object.keys(fields.clientApps).join(',') : undefined,
        };
        this.warn(sharedMessages.getMessage('SecurityWarning'));
        this.print(returnValue);
        return returnValue;
    }
    print(result) {
        this.log();
        const tableRows = Object.entries(result)
            .filter(([, value]) => value !== undefined && value !== null) // some values won't exist
            .sort() // this command always alphabetizes the table rows
            .map(([key, value]) => ({
            key: camelCaseToTitleCase(key),
            value: typeof value === 'string' ? getStyledValue(key, value) : value,
        }));
        this.table({
            overflow: 'wrap',
            data: tableRows,
            columns: [
                { key: 'key', name: 'KEY' },
                { key: 'value', name: 'VALUE' },
            ],
            title: 'Org Description',
        });
    }
    async getScratchOrgInformation(fields) {
        const hubOrg = await this.org.getDevHubOrg();
        // we know this is a scratch org so it must have a hubOrg and that'll have a username
        const hubUsername = hubOrg?.getUsername();
        // This query can return multiple records that match the 15 char ID because `ScratchOrgInfo.ScratchOrg` isn't a case-sensitive field
        // so we look for the record that matches the scratch org username in the auth file.
        // If that doesn't match (e.g., when calling `org display` with a username that is not the scratch org admin), use the instance URL
        const result = (await OrgListUtil.retrieveScratchOrgInfoFromDevHub(hubUsername, [trimTo15(fields.orgId)])).find((rec) => rec.SignupUsername === fields.username || rec.LoginUrl === fields.instanceUrl);
        if (result) {
            return {
                status: result.Status,
                devHubId: hubUsername,
                expirationDate: result.ExpirationDate,
                createdBy: result.CreatedBy?.Username,
                edition: result.Edition ?? undefined, // null for snapshot orgs, possibly others.  Marking it undefined keeps it out of json output
                namespace: result.Namespace ?? undefined, // may be null on server
                orgName: result.OrgName,
                createdDate: result.CreatedDate,
                signupUsername: result.SignupUsername,
            };
        }
        throw new SfError(messages.getMessage('noScratchOrgInfoError', [trimTo15(fields.orgId), hubUsername]), 'NoScratchInfo', [messages.getMessage('noScratchOrgInfoAction')]);
    }
}
//# sourceMappingURL=display.js.map