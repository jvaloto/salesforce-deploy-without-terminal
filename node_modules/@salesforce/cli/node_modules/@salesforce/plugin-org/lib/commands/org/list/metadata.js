/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import fs from 'node:fs';
import { Messages } from '@salesforce/core';
import { Flags, loglevel, requiredOrgFlagWithDeprecations, SfCommand } from '@salesforce/sf-plugins-core';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-org', 'list.metadata');
export class ListMetadata extends SfCommand {
    static summary = messages.getMessage('summary');
    static description = messages.getMessage('description');
    static examples = messages.getMessages('examples');
    static aliases = ['force:mdapi:listmetadata'];
    static deprecateAliases = true;
    static flags = {
        'api-version': Flags.orgApiVersion({
            aliases: ['apiversion', 'a'],
            deprecateAliases: true,
            summary: messages.getMessage('flags.api-version.summary'),
        }),
        loglevel,
        'target-org': requiredOrgFlagWithDeprecations,
        'output-file': Flags.file({
            aliases: ['resultfile'],
            deprecateAliases: true,
            char: 'f',
            summary: messages.getMessage('flags.output-file.summary'),
        }),
        'metadata-type': Flags.string({
            aliases: ['metadatatype'],
            deprecateAliases: true,
            char: 'm',
            summary: messages.getMessage('flags.metadata-type.summary'),
            required: true,
        }),
        folder: Flags.string({
            summary: messages.getMessage('flags.folder.summary'),
            description: messages.getMessage('flags.folder.description'),
        }),
    };
    async run() {
        const { flags } = await this.parse(ListMetadata);
        const conn = flags['target-org'].getConnection(flags['api-version']);
        const query = flags.folder
            ? { type: flags['metadata-type'], folder: flags.folder }
            : { type: flags['metadata-type'] };
        const listResult = await conn.metadata.list(query, flags['api-version']);
        if (flags['output-file']) {
            fs.writeFileSync(flags['output-file'], JSON.stringify(listResult, null, 2));
            this.logSuccess(`Wrote result file to ${flags['output-file']}.`);
        }
        else if (listResult?.length) {
            this.table({
                data: listResult.map((md) => ({
                    'Created By': md.createdByName,
                    'Created Date': md.createdDate.split('T')[0],
                    'Full Name': md.fullName,
                    Id: md.id,
                    'Last Modified By': md.lastModifiedByName,
                    'Last Modified': md.lastModifiedDate.split('T')[0],
                    'Manageable State': md.manageableState,
                    'Namespace Prefix': md.namespacePrefix,
                })),
                title: flags['metadata-type'],
                sort: {
                    'Manageable State': 'asc',
                },
            });
        }
        else {
            this.warn(messages.getMessage('noMatchingMetadata', [flags['metadata-type'], conn.getUsername()]));
        }
        return listResult;
    }
}
//# sourceMappingURL=metadata.js.map