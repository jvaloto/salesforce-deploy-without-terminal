"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecomposedPermissionSetFinalizer = void 0;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const node_path_1 = require("node:path");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const constants_1 = require("../../common/constants");
const streams_1 = require("../streams");
const transactionFinalizer_1 = require("./transactionFinalizer");
/**
 * Merges child components that share the same related object (/objectSettings/<object name>.objectSettings) in the conversion pipeline
 * into a single file.
 *
 * Inserts unclaimed child components into the parent that belongs to the default package
 */
class DecomposedPermissionSetFinalizer extends transactionFinalizer_1.ConvertTransactionFinalizer {
    transactionState = {
        parentToChild: new Map(),
    };
    /** to support custom presets (the only way this code should get hit at all pass in the type from a transformer that has registry access */
    permissionSetType;
    // have to maintain the existing interface
    // eslint-disable-next-line @typescript-eslint/require-await, @typescript-eslint/no-unused-vars
    async finalize(defaultDirectory) {
        if (this.transactionState.parentToChild.size === 0) {
            return [];
        }
        const agg = [];
        this.transactionState.parentToChild.forEach((children, parent) => {
            // iterate over children and build PermissionSet data structure
            const permset = new Map();
            for (const child of children) {
                for (const [key, value] of Object.entries(child)) {
                    const existingEntry = permset.get(key);
                    if (existingEntry) {
                        if (Array.isArray(value)) {
                            permset.set(key, existingEntry.concat(value));
                        }
                        else {
                            existingEntry.push(value);
                            permset.set(key, existingEntry);
                        }
                    }
                    else {
                        permset.set(key, (0, kit_1.ensureArray)(value));
                    }
                }
            }
            agg.push({
                component: {
                    type: (0, ts_types_1.ensure)(this.permissionSetType, 'DecomposedPermissionSetFinalizer should have set PermissionSetType'),
                    fullName: (0, ts_types_1.ensureString)(parent),
                },
                writeInfos: [
                    {
                        output: (0, node_path_1.join)((0, ts_types_1.ensure)(this.permissionSetType?.directoryName, 'directoryName missing from PermissionSet type'), `${parent}.permissionset`),
                        source: new streams_1.JsToXml({
                            PermissionSet: {
                                [constants_1.XML_NS_KEY]: constants_1.XML_NS_URL,
                                ...Object.fromEntries(permset),
                            },
                        }),
                    },
                ],
            });
        });
        return agg;
    }
}
exports.DecomposedPermissionSetFinalizer = DecomposedPermissionSetFinalizer;
//# sourceMappingURL=decomposedPermissionSetFinalizer.js.map