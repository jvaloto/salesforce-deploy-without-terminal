import { JsonMap } from '@salesforce/ts-types';
import { NodeFSTreeContainer, TreeContainer } from '../../resolve/treeContainers';
import { SourceComponent } from '../../resolve/sourceComponent';
import { WriterFormat } from '../types';
import { ConvertTransactionFinalizer } from './transactionFinalizer';
type NonDecompositionState = {
    childrenByUniqueElement: Map<string, JsonMap>;
    exampleComponent?: SourceComponent;
};
/**
 * Merges child components that share the same parent in the conversion pipeline
 * into a single file.
 *
 * Inserts unclaimed child components into the parent that belongs to the default package
 */
export declare class NonDecompositionFinalizer extends ConvertTransactionFinalizer<NonDecompositionState> {
    transactionState: NonDecompositionState;
    protected mergeMap: Map<string, Map<string, JsonMap>>;
    protected parentComponentMap: Map<string, SourceComponent>;
    protected tree: TreeContainer | undefined;
    finalize(defaultDirectory: string, tree?: NodeFSTreeContainer): Promise<WriterFormat[]>;
    private initChildMapping;
    /**
     * check both top-level maps and make sure there are defaults
     */
    private ensureDefaults;
    /**
     * Returns all the components of the incoming type in the project.
     *
     * Some components are not resolved during component resolution.
     * This typically only happens when a specific source path was resolved. This is problematic for
     * nondecomposed metadata types (like CustomLabels) because we need to know the location of each
     * child type before recomposing the final xml.
     * The labels could belong in any of the files OR need to go in the default location which already contains labels
     */
    private getAllComponentsOfType;
    /**
     * Populate the mergeMap with all the children of all the local components
     */
    private initMergeMap;
}
export {};
