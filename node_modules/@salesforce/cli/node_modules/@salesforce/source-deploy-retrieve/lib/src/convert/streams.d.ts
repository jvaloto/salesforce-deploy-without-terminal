import { pipeline as cbPipeline, Readable, Stream, Transform, Writable } from 'node:stream';
import { JsonMap } from '@salesforce/ts-types';
import { Logger } from '@salesforce/core';
import { SourceComponent } from '../resolve/sourceComponent';
import { SourcePath } from '../common/types';
import { ComponentSet } from '../collections/componentSet';
import { RegistryAccess } from '../registry/registryAccess';
import { FileResponseSuccess } from '../client/types';
import { ForceIgnore } from '../resolve';
import { ConvertContext } from './convertContext/convertContext';
import { SfdxFileFormat, WriterFormat } from './types';
export declare const pipeline: typeof cbPipeline.__promisify__;
export declare const stream2buffer: (stream: Stream) => Promise<Buffer>;
export declare class ComponentConverter extends Transform {
    private targetFormat;
    private mergeSet?;
    private defaultDirectory?;
    readonly context: ConvertContext;
    private transformerFactory;
    constructor(targetFormat: SfdxFileFormat, registry: RegistryAccess, mergeSet?: ComponentSet | undefined, defaultDirectory?: string | undefined);
    _transform(chunk: SourceComponent, encoding: string, callback: (err: Error | undefined, data: WriterFormat) => void): Promise<void>;
    /**
     * Called at the end when all components have passed through the pipeline. Finalizers
     * take care of any additional work to be done at this stage e.g. recomposing child components.
     */
    _flush(callback: (err: Error | undefined, data?: WriterFormat) => void): Promise<void>;
}
export declare abstract class ComponentWriter extends Writable {
    protected rootDestination?: SourcePath;
    protected logger: Logger;
    constructor(rootDestination?: SourcePath);
}
export declare class StandardWriter extends ComponentWriter {
    /** filepaths that converted files were written to */
    readonly converted: string[];
    readonly deleted: FileResponseSuccess[];
    readonly forceignore: ForceIgnore;
    constructor(rootDestination: SourcePath);
    _write(chunk: WriterFormat, encoding: string, callback: (err?: Error) => void): Promise<void>;
}
export declare class ZipWriter extends ComponentWriter {
    /**
     * Count of files (not directories) added to the zip file.
     */
    fileCount: number;
    private zip;
    private zipBuffer?;
    constructor(rootDestination?: SourcePath);
    get buffer(): Buffer | undefined;
    _write(chunk: WriterFormat, encoding: string, callback: (err?: Error) => void): Promise<void>;
    _final(callback: (err?: Error) => void): Promise<void>;
    addToZip(contents: string | Readable | Buffer, path: SourcePath): void;
}
/**
 * Convenient wrapper to serialize a js object to XML content. Implemented as a stream
 * to be used as a valid source for ComponentWriters in the conversion pipeline,
 * even though it's not beneficial in the typical way a stream is.
 */
export declare class JsToXml extends Readable {
    private xmlObject;
    constructor(xmlObject: JsonMap);
    _read(): void;
}
