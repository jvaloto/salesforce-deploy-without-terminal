"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecomposeExternalServiceRegistrationTransformer = void 0;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = __importStar(require("node:path"));
const node_stream_1 = require("node:stream");
const yaml = __importStar(require("yaml"));
const fast_xml_parser_1 = require("fast-xml-parser");
const common_1 = require("../../common");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
const xmlDeclaration = '<?xml version="1.0" encoding="UTF-8"?>\n';
class DecomposeExternalServiceRegistrationTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    async toSourceFormat(input) {
        this.context.decomposedExternalServiceRegistration.externalServiceRegistration ??=
            this.registry.getTypeByName('ExternalServiceRegistration');
        const writeInfos = [];
        const { component } = input;
        const outputDir = path.join(this.getOutputFolder('source', component), this.context.decomposedExternalServiceRegistration.externalServiceRegistration.directoryName);
        const xmlContent = { ...(await component.parseXml()).ExternalServiceRegistration };
        // Extract schema content
        const schemaContent = xmlContent.schema ?? '';
        const schemaType = xmlContent.schemaUploadFileExtension ?? this.getSchemaType(schemaContent);
        const asYaml = schemaType === 'yaml' ? schemaContent : yaml.stringify(JSON.parse(schemaContent));
        const schemaFileName = `${component.fullName}.yaml`;
        const schemaFilePath = path.join(path.dirname(outputDir), schemaFileName);
        // make sure the schema type is set
        xmlContent.schemaUploadFileExtension = schemaType;
        // Write schema content to file
        writeInfos.push({
            source: node_stream_1.Readable.from(asYaml),
            output: schemaFilePath,
        });
        // Remove schema content from ESR content
        delete xmlContent.schema;
        // Write remaining ESR content to file
        const esrFileName = `${component.fullName}.externalServiceRegistration`;
        const esrFilePath = path.join(path.dirname(outputDir), `${esrFileName}${common_1.META_XML_SUFFIX}`);
        const xmlBuilder = new fast_xml_parser_1.XMLBuilder({
            format: true,
            ignoreAttributes: false,
            suppressUnpairedNode: true,
            processEntities: true,
            indentBy: '    ',
        });
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const source = xmlBuilder.build({ ExternalServiceRegistration: xmlContent });
        writeInfos.push({
            source: node_stream_1.Readable.from(Buffer.from(xmlDeclaration + source)),
            output: esrFilePath,
        });
        return writeInfos;
    }
    async toMetadataFormat(component) {
        // only need to do this once
        this.context.decomposedExternalServiceRegistration.externalServiceRegistration ??=
            this.registry.getTypeByName('ExternalServiceRegistration');
        const esrFilePath = component.xml;
        const esrContent = { ...(await component.parseXml()).ExternalServiceRegistration };
        // Read schema content from file
        const schemaFileName = `${component.fullName}.yaml`; // or .json based on your logic
        const schemaFilePath = path.join(path.dirname(esrFilePath ?? ''), schemaFileName);
        // load the schema content from the file
        const schemaContent = (await component.tree.readFile(schemaFilePath)).toString();
        // Add schema content back to ESR content in its original format
        // if the original format was JSON, then convert the yaml to json otherwise leave as is
        esrContent.schema =
            esrContent.schemaUploadFileExtension === 'json'
                ? JSON.stringify(yaml.parse(schemaContent), undefined, 2)
                : schemaContent;
        // Write combined content back to md format
        this.context.decomposedExternalServiceRegistration.transactionState.esrRecords.set(component.fullName, {
            // @ts-expect-error Object literal may only specify known properties
            [common_1.XML_NS_KEY]: common_1.XML_DECL,
            ...esrContent,
        });
        return [];
    }
    // eslint-disable-next-line class-methods-use-this
    getOutputFolder(format, component, mergeWith) {
        const base = format === 'source' ? common_1.DEFAULT_PACKAGE_ROOT_SFDX : '';
        const { type } = mergeWith ?? component;
        return path.join(base, type.directoryName);
    }
    // eslint-disable-next-line class-methods-use-this
    getSchemaType(content) {
        return content.trim().startsWith('{') ? 'json' : 'yaml';
    }
}
exports.DecomposeExternalServiceRegistrationTransformer = DecomposeExternalServiceRegistrationTransformer;
//# sourceMappingURL=decomposeExternalServiceRegistrationTransformer.js.map