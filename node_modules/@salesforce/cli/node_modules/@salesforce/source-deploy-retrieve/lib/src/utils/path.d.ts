import { Optional } from '@salesforce/ts-types';
import { SfdxFileFormat } from '../convert/types';
import { SourcePath } from '../common/types';
import { MetadataXml } from '../resolve/types';
import { MetadataType } from '../registry/types';
/**
 * Get the file or directory name at the end of a path. Different from `path.basename`
 * in that it strips anything after the first '.' in the name.
 *
 * @param fsPath The path to evaluate
 */
export declare function baseName(fsPath: SourcePath): string;
/**
 * the above baseName function doesn't handle components whose names have a `.` in them.
 * this will handle that, but requires you to specify the mdType to check suffixes for.
 *
 * @param fsPath The path to evaluate
 */
export declare function baseWithoutSuffixes(fsPath: SourcePath, mdType: MetadataType): string;
/**
 * Get the name of file path extension. Different from path.extname in that it
 * does not include the '.' in the extension name. Returns an empty string if
 * there is no extension.
 *
 * @param fsPath The path to evaluate
 */
export declare function extName(fsPath: SourcePath): string;
/**
 * Get the name of the parent to the last portion of a path
 *
 * @param fsPath The path to evaluate
 */
export declare function parentName(fsPath: SourcePath): string;
/**
 * Trim a path up until and including the given part. Returns `fsPath`
 * if the path `part` was not found.
 *
 * @param fsPath Path to trim
 * @param part Path part to trim up until
 * @param untilLast Trim until the *last* occurrence of `part`
 */
export declare function trimUntil(fsPath: SourcePath, part: string, untilLast?: boolean): string;
/**
 * Returns the `MetadataXml` info from a given file path. If the path is not a
 * metadata xml file (-meta.xml), returns `undefined`.
 *
 * @param fsPath - File path to parse
 * @returns MetadataXml info or undefined
 */
export declare function parseMetadataXml(fsPath: string): Optional<MetadataXml>;
/**
 * Returns the fullName for a nested metadata source file. This is for metadata
 * types that can be nested more than 1 level such as report and reportFolder,
 * dashboard and dashboardFolder, etc. It uses the directory name for the metadata type
 * as the starting point (non-inclusively) to parse the fullName.
 *
 * Examples:
 * (source format path)
 * fsPath: force-app/main/default/reports/foo/bar/My_Report.report-meta.xml
 * returns: foo/bar/My_Report
 *
 * (mdapi format path)
 * fsPath: unpackaged/reports/foo/bar-meta.xml
 * returns: foo/bar
 *
 * @param fsPath - File path to parse
 * @param directoryName - name of directory to use as a parsing index
 * @returns the FullName
 */
export declare function parseNestedFullName(fsPath: string, directoryName: string): string | undefined;
export declare const calculateRelativePath: (format: SfdxFileFormat) => (types: {
    self: MetadataType;
    parentType?: MetadataType;
}) => (fullName: string) => (fsPath: string) => string;
/** (a)(b)=> a/b */
export declare const fnJoin: (a: string) => (b: string) => string;
