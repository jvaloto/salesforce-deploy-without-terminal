"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toLegacyMemberRevision = exports.writeTrackingFile = exports.upgradeFileContents = exports.revisionToRemoteChangeElement = exports.readFileContents = exports.getFilePath = exports.FILENAME = void 0;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const functions_1 = require("../functions");
exports.FILENAME = 'maxRevision.json';
const getFilePath = (orgId) => node_path_1.default.join('.sf', 'orgs', orgId, exports.FILENAME);
exports.getFilePath = getFilePath;
const readFileContents = async (filePath) => {
    try {
        const contents = await node_fs_1.default.promises.readFile(filePath, 'utf8');
        const parsedContents = (0, kit_1.parseJsonMap)(contents, filePath);
        if (parsedContents.fileVersion === 1) {
            return parsedContents;
        }
        core_1.Logger.childFromRoot('remoteSourceTrackingService:readFileContents').debug(`older tracking file version, found ${parsedContents.fileVersion ?? 'undefined'}. Upgrading file contents.  Some expected data may be missing`);
        return (0, exports.upgradeFileContents)(parsedContents);
    }
    catch (e) {
        core_1.Logger.childFromRoot('remoteSourceTrackingService:readFileContents').debug(`Error reading or parsing file file at ${filePath}.  Will treat as an empty file.`, e);
        return {};
    }
};
exports.readFileContents = readFileContents;
const revisionToRemoteChangeElement = (memberRevision) => ({
    type: memberRevision.MemberType,
    name: memberRevision.MemberName,
    deleted: memberRevision.IsNameObsolete,
    modified: memberRevision.IsNewMember === false,
    revisionCounter: memberRevision.RevisionCounter,
    changedBy: memberRevision.ChangedBy,
    memberIdOrName: memberRevision.MemberIdOrName,
    lastModifiedDate: memberRevision.LastModifiedDate,
});
exports.revisionToRemoteChangeElement = revisionToRemoteChangeElement;
const upgradeFileContents = (contents) => ({
    fileVersion: 1,
    serverMaxRevisionCounter: contents.serverMaxRevisionCounter,
    // @ts-expect-error the old file didn't store the IsNewMember field or any indication of whether the member was add/modified
    sourceMembers: Object.fromEntries(
    // it's the old version
    Object.entries(contents.sourceMembers).map(([key, value]) => [
        (0, functions_1.getMetadataKey)((0, functions_1.getMetadataTypeFromLegacyKey)(key), (0, functions_1.getMetadataNameFromLegacyKey)(key)),
        {
            MemberName: (0, functions_1.getMetadataNameFromLegacyKey)(key),
            MemberType: value.memberType,
            IsNameObsolete: value.isNameObsolete,
            RevisionCounter: value.serverRevisionCounter,
            lastRetrievedFromServer: value.lastRetrievedFromServer ?? undefined,
            ChangedBy: 'unknown',
            MemberIdOrName: 'unknown',
            LastModifiedDate: 'unknown',
        },
    ])),
});
exports.upgradeFileContents = upgradeFileContents;
const writeTrackingFile = async ({ filePath, maxCounter, members, }) => {
    const lockResult = await (0, core_1.lockInit)(filePath);
    const CURRENT_FILE_VERSION_ENV = core_1.envVars.getNumber('SF_SOURCE_TRACKING_FILE_VERSION') ?? 0;
    const contents = CURRENT_FILE_VERSION_ENV === 1
        ? {
            fileVersion: 1,
            serverMaxRevisionCounter: maxCounter,
            sourceMembers: Object.fromEntries(members),
        }
        : {
            fileVersion: 0,
            serverMaxRevisionCounter: maxCounter,
            sourceMembers: Object.fromEntries(Array.from(members.entries()).map(exports.toLegacyMemberRevision)),
        };
    await lockResult.writeAndUnlock(JSON.stringify(contents, null, 4));
};
exports.writeTrackingFile = writeTrackingFile;
const toLegacyMemberRevision = ([, member]) => [
    (0, functions_1.getLegacyMetadataKey)(member.MemberType, member.MemberName),
    {
        memberType: member.MemberType,
        serverRevisionCounter: member.RevisionCounter,
        lastRetrievedFromServer: member.lastRetrievedFromServer ?? null,
        isNameObsolete: member.IsNameObsolete,
    },
];
exports.toLegacyMemberRevision = toLegacyMemberRevision;
//# sourceMappingURL=fileOperations.js.map